---
alwaysApply: true
---
# Data Handling Patterns

This project enforces strict patterns for data operations to ensure type safety, security, and proper separation of concerns. **ALL data operations MUST go through helper functions in the `db/queries` directory.**

## Database Query Layer - Required Architecture

**ALWAYS** use helper functions from `db/queries` directory for all database operations. Never write direct database queries in components or actions.

### ✅ CORRECT: Using Query Helpers

```typescript
// app/decks/page.tsx - Server Component
import { auth } from '@clerk/nextjs/server';
import { redirect } from 'next/navigation';
import { getUserDecks } from '@/db/queries/deck-queries';

export default async function DecksPage() {
  const { userId } = await auth();
  if (!userId) {
    redirect('/');
  }

  // ✅ Data fetching through query helper
  const decks = await getUserDecks(userId);

  return (
    <div>
      {decks.map(deck => (
        <div key={deck.id}>{deck.title}</div>
      ))}
    </div>
  );
}
```

### ✅ CORRECT: Query Helper Implementation

```typescript
// db/queries/deck-queries.ts
import { db } from '@/db';
import { decksTable } from '@/db/schema';
import { eq, and } from 'drizzle-orm';

export async function getUserDecks(userId: string) {
  return await db.select()
    .from(decksTable)
    .where(eq(decksTable.userId, userId));
}

export async function getDeckById(deckId: number, userId: string) {
  const [deck] = await db.select()
    .from(decksTable)
    .where(and(
      eq(decksTable.id, deckId),
      eq(decksTable.userId, userId)
    ));
  return deck;
}

export async function createDeck(data: { userId: string; title: string; description?: string }) {
  const [newDeck] = await db.insert(decksTable).values(data).returning();
  return newDeck;
}

export async function updateDeck(deckId: number, userId: string, data: Partial<{ title: string; description: string }>) {
  const [updatedDeck] = await db.update(decksTable)
    .set({ ...data, updatedAt: new Date() })
    .where(and(
      eq(decksTable.id, deckId),
      eq(decksTable.userId, userId)
    ))
    .returning();
  return updatedDeck;
}

export async function deleteDeck(deckId: number, userId: string) {
  await db.delete(decksTable)
    .where(and(
      eq(decksTable.id, deckId),
      eq(decksTable.userId, userId)
    ));
}
```

### ❌ WRONG: Client Component Data Fetching

```typescript
// ❌ NEVER do this - Client Component fetching
'use client';
import { useEffect, useState } from 'react';

export default function DecksPage() {
  const [decks, setDecks] = useState([]);
  
  useEffect(() => {
    // ❌ WRONG: Fetching in Client Component
    fetch('/api/decks').then(res => res.json()).then(setDecks);
  }, []);
  
  return <div>...</div>;
}
```

### ❌ WRONG: Direct Database Queries in Components

```typescript
// ❌ NEVER do this - Direct database queries in components
import { db } from '@/db';
import { decksTable } from '@/db/schema';
import { eq } from 'drizzle-orm';

export default async function DecksPage() {
  const { userId } = await auth();
  
  // ❌ WRONG: Direct database query in component
  const decks = await db.select()
    .from(decksTable)
    .where(eq(decksTable.userId, userId));
    
  return <div>...</div>;
}
```

## Database Mutations - Server Actions with Query Helpers

**ALWAYS** use Server Actions for all database mutations (INSERT, UPDATE, DELETE). **ALWAYS** use query helpers from `db/queries` directory. Never use API routes for mutations.

### ✅ CORRECT: Server Action with Query Helpers

```typescript
// app/actions/deck-actions.ts
'use server';

import { auth } from '@clerk/nextjs/server';
import { revalidatePath } from 'next/cache';
import { z } from 'zod';
import { createDeck, updateDeck, deleteDeck } from '@/db/queries/deck-queries';

// ✅ Zod schema for validation
const CreateDeckSchema = z.object({
  title: z.string().min(1, 'Title is required').max(255, 'Title too long'),
  description: z.string().optional(),
});

// ✅ TypeScript type from Zod schema
type CreateDeckInput = z.infer<typeof CreateDeckSchema>;

export async function createDeckAction(input: CreateDeckInput) {
  try {
    // ✅ Validate input with Zod
    const validatedInput = CreateDeckSchema.parse(input);
    
    const { userId } = await auth();
    if (!userId) {
      throw new Error('Unauthorized');
    }

    // ✅ Database mutation through query helper
    const newDeck = await createDeck({
      userId,
      title: validatedInput.title,
      description: validatedInput.description,
    });

    revalidatePath('/decks');
    return { success: true, deck: newDeck };
  } catch (error) {
    console.error('Error creating deck:', error);
    return { success: false, error: 'Failed to create deck' };
  }
}
```

### ❌ WRONG: API Route for Mutations

```typescript
// ❌ NEVER do this - API route for mutations
// app/api/decks/route.ts
export async function POST(request: Request) {
  // ❌ WRONG: Use Server Actions instead
  const body = await request.json();
  // ... mutation logic
}
```

### ❌ WRONG: Direct Database Queries in Server Actions

```typescript
// ❌ NEVER do this - Direct database queries in Server Actions
'use server';
import { db } from '@/db';
import { decksTable } from '@/db/schema';

export async function createDeck(input: CreateDeckInput) {
  // ❌ WRONG: Direct database query in Server Action
  const [newDeck] = await db.insert(decksTable).values(input).returning();
  return newDeck;
}
```

## Data Validation - Zod Required

**ALWAYS** use Zod for data validation. **NEVER** use FormData as a type.

### ✅ CORRECT: Zod Validation with Query Helpers

```typescript
import { z } from 'zod';
import { updateCard } from '@/db/queries/card-queries';

// ✅ Define Zod schema
const UpdateCardSchema = z.object({
  id: z.number().int().positive(),
  front: z.string().min(1, 'Front text is required'),
  back: z.string().min(1, 'Back text is required'),
  difficulty: z.number().int().min(1).max(5).default(1),
});

// ✅ Extract TypeScript type from Zod schema
type UpdateCardInput = z.infer<typeof UpdateCardSchema>;

// ✅ Server Action with validation and query helper
export async function updateCardAction(input: UpdateCardInput) {
  try {
    // ✅ Validate with Zod
    const validatedInput = UpdateCardSchema.parse(input);
    
    // ✅ Use query helper for database operation
    const result = await updateCard(validatedInput.id, validatedInput);
      
    return { success: true, card: result };
  } catch (error) {
    if (error instanceof z.ZodError) {
      return { success: false, errors: error.errors };
    }
    return { success: false, error: 'Validation failed' };
  }
}
```

### ❌ WRONG: FormData or No Validation

```typescript
// ❌ NEVER do this - FormData type
export async function createCard(formData: FormData) {
  // ❌ WRONG: Using FormData type
  const title = formData.get('title') as string;
  // ❌ WRONG: No validation
}

// ❌ NEVER do this - No validation
export async function updateCard(input: any) {
  // ❌ WRONG: No type safety or validation
  await db.update(cardsTable).set(input);
}
```

## Query Helper Organization

### Required Directory Structure

```
db/
├── index.ts              # Database connection
├── schema.ts             # Database schema
└── queries/              # Query helper functions
    ├── deck-queries.ts   # Deck-related queries
    ├── card-queries.ts   # Card-related queries
    └── index.ts          # Export all queries
```

### Query Helper File Pattern

```typescript
// db/queries/deck-queries.ts
import { db } from '@/db';
import { decksTable } from '@/db/schema';
import { eq, and, desc } from 'drizzle-orm';

// ✅ All database operations for decks
export async function getUserDecks(userId: string) {
  return await db.select()
    .from(decksTable)
    .where(eq(decksTable.userId, userId))
    .orderBy(desc(decksTable.updatedAt));
}

export async function getDeckById(deckId: number, userId: string) {
  const [deck] = await db.select()
    .from(decksTable)
    .where(and(
      eq(decksTable.id, deckId),
      eq(decksTable.userId, userId)
    ));
  return deck;
}

export async function createDeck(data: {
  userId: string;
  title: string;
  description?: string;
}) {
  const [newDeck] = await db.insert(decksTable).values(data).returning();
  return newDeck;
}

export async function updateDeck(
  deckId: number, 
  userId: string, 
  data: Partial<{ title: string; description: string }>
) {
  const [updatedDeck] = await db.update(decksTable)
    .set({ ...data, updatedAt: new Date() })
    .where(and(
      eq(decksTable.id, deckId),
      eq(decksTable.userId, userId)
    ))
    .returning();
  return updatedDeck;
}

export async function deleteDeck(deckId: number, userId: string) {
  await db.delete(decksTable)
    .where(and(
      eq(decksTable.id, deckId),
      eq(decksTable.userId, userId)
    ));
}
```

## Required Imports

Always include these imports for data handling:

```typescript
// Server Actions
'use server';
import { revalidatePath } from 'next/cache';

// Query Helpers (NOT direct database imports)
import { getUserDecks, createDeck, updateDeck } from '@/db/queries/deck-queries';
import { getCardsByDeckId, createCard, updateCard } from '@/db/queries/card-queries';

// Authentication
import { auth } from '@clerk/nextjs/server';

// Validation
import { z } from 'zod';
```

## File Organization

- **Query Helpers**: `db/queries/` directory (organized by entity)
- **Server Actions**: `app/actions/` directory (use query helpers)
- **Server Components**: `app/` directory (use query helpers)
- **Client Components**: Mark with `'use client'` directive
- **Validation Schemas**: Co-locate with Server Actions or create `lib/validations.ts`

## Error Handling Pattern

```typescript
export async function serverAction(input: ValidatedInput) {
  try {
    // 1. Validate input
    const validatedInput = Schema.parse(input);
    
    // 2. Authenticate user
    const { userId } = await auth();
    if (!userId) throw new Error('Unauthorized');
    
    // 3. Perform database operation through query helper
    const result = await queryHelper(validatedInput, userId);
    
    // 4. Revalidate cache
    revalidatePath('/path');
    
    // 5. Return success
    return { success: true, data: result };
  } catch (error) {
    if (error instanceof z.ZodError) {
      return { success: false, errors: error.errors };
    }
    console.error('Server action error:', error);
    return { success: false, error: 'Operation failed' };
  }
}
```

## Security Requirements

- **ALWAYS** validate user authentication in Server Actions
- **ALWAYS** validate user ownership of data in query helpers
- **ALWAYS** use Zod schemas for input validation
- **NEVER** trust client-side data without validation
- **ALWAYS** use TypeScript types derived from Zod schemas
- **ALWAYS** use query helpers for all database operations
- **NEVER** write direct database queries in components or actions

## Query Helper Benefits

- **Centralized Logic**: All database operations in one place
- **Type Safety**: Consistent TypeScript types across the app
- **Security**: User ownership validation in query helpers
- **Reusability**: Query helpers can be used across multiple components/actions
- **Maintainability**: Easy to update database logic in one location
- **Testing**: Query helpers can be easily unit tested

## Common Patterns to AVOID

❌ **NEVER** do these:
- Fetch data in Client Components
- Use API routes for mutations
- Write direct database queries in components
- Write direct database queries in Server Actions
- Use FormData as a type
- Skip Zod validation
- Use `any` types for validated data
- Trust client-side data without validation
- Mix data fetching and mutations in the same component
- Import `db` or schema tables directly in components/actions